.TH "Cola< T >" 3 "Viernes, 8 de Noviembre de 2019" "ClasePila_Max(Int)" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Cola< T > \- T\&.D\&.A\&. \fBCola\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <cola\&.h>\fP
.SS "Métodos públicos"

.in +1c
.ti -1c
.RI "\fBCola\fP ()"
.br
.RI "Constructor por defecto\&. "
.ti -1c
.RI "\fBCola\fP (const \fBCola\fP< T > &original)"
.br
.RI "Constructor de copias\&. "
.ti -1c
.RI "\fB~Cola\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "\fBCola\fP & \fBoperator=\fP (const \fBCola\fP< T > &otra)"
.br
.RI "Operador de asignación\&. "
.ti -1c
.RI "bool \fBvacia\fP () const"
.br
.RI "Comprueba si la cola está vacía\&. "
.ti -1c
.RI "T & \fBfrente\fP ()"
.br
.RI "Devuelve el elemento del frente de la cola\&. "
.ti -1c
.RI "const T & \fBfrente\fP () const"
.br
.RI "Devuelve el elemento del frente de una cola constante\&. "
.ti -1c
.RI "void \fBponer\fP (const T &elem)"
.br
.RI "Añade un elemento al final de la cola\&. "
.ti -1c
.RI "void \fBquitar\fP ()"
.br
.RI "Quita el elemento del frente de la cola\&. "
.ti -1c
.RI "int \fBnum_elementos\fP () const"
.br
.RI "Devuelve el número de elementos de la cola\&. "
.in -1c
.SH "Descripción detallada"
.PP 

.SS "template<class T>
.br
class Cola< T >"
T\&.D\&.A\&. \fBCola\fP\&. 

Una instancia \fIc\fP del tipo de dato abstracto \fBCola\fP sobre un dominio \fIT\fP es una sucesión finita de elementos del mismo con un funcionamiento \fIFIFO\fP (First In, First Out})\&. En una cola, las operaciowhile( !pila1\&.empty() ) { p = pila1\&.top(); pila1\&.pop(); cout << '(' << p\&.elemento << ',' << p\&.maximo << ')' << endl; }nes de inserción tienen lugar en uno de los extremos, denominado \fIfinal\fP de la cola, mientras que el borrado y consulta se lleva a cabo en el otro extremo, denominado \fIfrente\fP de la cola\&. Una cola de longitud \fIn\fP la denotamos
.PP
.IP "\(bu" 2
<a1,a2,a3,\&.\&.,an<
.PP
.PP
En esta cola, tendremos acceso únicamente al elemento del \fIFrente\fP, es decir, a \fIa1\fP\&. El borrado o consulta de un elemento será sobre \fIa1\fP, mientras que la inserción de un nuevo elemento se hará después de \fIan\fP (final de la cola)\&.
.PP
Si n=0 diremos que la cola está vacía\&.
.PP
El espacio requerido para el almacenamiento es O(n), donde n es el número de elementos de la cola\&.
.PP
\fBAutor:\fP
.RS 4
J\&. Fdez-Valdivia 
.RE
.PP
\fBFecha:\fP
.RS 4
Octubre 2011 
.RE
.PP

.SH "Documentación del constructor y destructor"
.PP 
.SS "template<class T> \fBCola\fP< T >::\fBCola\fP (const \fBCola\fP< T > & original)"

.PP
Constructor de copias\&. 
.PP
\fBParámetros:\fP
.RS 4
\fIoriginal\fP La cola de la que se hará la copia\&. 
.RE
.PP

.SH "Documentación de las funciones miembro"
.PP 
.SS "template<class T> \fBCola\fP& \fBCola\fP< T >::operator= (const \fBCola\fP< T > & otra)"

.PP
Operador de asignación\&. 
.PP
\fBParámetros:\fP
.RS 4
\fIotra\fP La cola que se va a asignar\&. 
.RE
.PP

.PP
Referenciado por Cola< Pareja >::Cola()\&.
.SS "template<class T> void \fBCola\fP< T >::poner (const T & elem)"

.PP
Añade un elemento al final de la cola\&. 
.PP
\fBParámetros:\fP
.RS 4
\fIelem\fP Elemento que se va a añadir\&. 
.RE
.PP

.PP
Referenciado por Cola< Pareja >::frente()\&.

.SH "Autor"
.PP 
Generado automáticamente por Doxygen para ClasePila_Max(Int) del código fuente\&.
